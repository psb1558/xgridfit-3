
#      Licensed under the Apache License, Version 2.0.
#      Copyright (c) 2006-20 by Peter S. Baker

default namespace = "http://xgridfit.sourceforge.net/Xgridfit2"
namespace a = "http://relaxng.org/ns/compatibility/annotations/1.0"
namespace xi = "http://www.w3.org/2001/XInclude"

YESNO = "yes" | "no"
various = message | no-warning | getinfo
movements =
    sh
  | al
  | ip
  | iup
  | top.level.mv
  | top.level.delta
  | control-value-delta
graphics =
    setvs
  | set-minimum-distance
  | srp
  | set-round-state
  | disable-instructions
  | enable-instructions
  | set-dropout-control
  | set-dropout-type
  | setcv
  | set-control-value-cut-in
  | set-delta-base
  | set-delta-shift
  | with-minimum-distance
  | with-round-state
  | wcv
  | with-control-value-cut-in
  | with-delta-base
  | with-delta-shift
  | restore-default
vars =
    set-equal | round
flow = callf | callm | callg | callp | if | compile-if
primitive = command | push
programming =
  various | movements | graphics | vars | flow | primitive
token.pnm = xsd:token {pattern = "\.notdef|[A-Za-z_][A-Za-z0-9_\.]{0,30}" }
att.p = attribute p { text }
att.r = attribute r { text }
att.val = attribute val { text }
att.n = attribute n { text }
att.nm = attribute nm { xsd:NCName }
att.ref = attribute ref { xsd:NCName }
att.target = attribute target { xsd:NCName }
att.color = attribute color { "gray" | "black" | "white" }
att.axis = attribute axis { "x" | "y" }
att.unit = attribute unit { "pixel" | "font" }
att.units.per.pixel = attribute units-per-pixel { "2" | "4" | "8" | "16" | "32" | "64" }
att.to-line = attribute to-line { "orthogonal" | "parallel" }
att.result-to = attribute result-to { xsd:NCName }
att.test = attribute test { text }
att.grid-fitted = attribute grid-fitted { YESNO }
att.whichpointer = attribute whichpointer { text }
att.id = attribute xml:id { xsd:ID }
att.round = attribute round { text }
att.set-rp0 = attribute set-rp0 { YESNO }
att.cut-in = attribute cut-in { YESNO }
att.compile-if = attribute compile-if { text }
att.di = attribute di { text }
att.pixel-distance = attribute pixel-distance { text }
att.boolean.min-distance = attribute min-distance { YESNO }
att.val.min-distance = attribute min-distance { text }
att.pnm = attribute pnm { token.pnm }
attlist.single.op =
  att.val,
  att.result-to?
attlist.val.with.name =
  att.val,
  att.nm
attlist.delta-set-basic =
  attribute size { xsd:nonNegativeInteger {maxInclusive = "47"} },
  attribute di { xsd:int {pattern = "[\-]?[1-8]"} }
attlist.vector.components =
  (attribute x-component { text },
   attribute y-component { text })
attlist.vector.store =
  (attribute x-component { xsd:NCName },
   attribute y-component { xsd:NCName })?
attlist.measurement =
  att.grid-fitted?,
  att.result-to?
model.set-vector =
  att.axis
model.with-vector =
  (att.axis, programming*)
#
# Top level
#
xgridfit =
  element xgridfit{
        att.id?&
        glyph-select?&
        infile?&
        outfile?&
        outfile-base?&
        no-compile?&
        legacy-functions?&
        prep?&
        cn*&
	alias*&
        var*&
        round-state*&
        \default*&
        cv*&
	cvar?&
        fn*&
        mo*&
        gl*&
        xg.xi.include*
  }
#
# Value declarations
#
cn =
  element cn { attlist.val.with.name, empty }
var =
  element var { attlist.var, empty }
attlist.var &=
  att.nm,
  att.val?
alias =
  element alias { attlist.alias, empty }
attlist.alias &=
  att.nm,
  att.target
#
# Controlling compilation of glyph programs
#
glyph-select =
  element glyph-select { list { token.pnm* } }
no-compile =
  element no-compile { (gl | xg.xi.include)* }
#
# Script I/O
#
infile =
  element infile { text }
outfile =
  element outfile { text }
outfile-base =
  element outfile-base { xsd:anyURI }
#
# Top-level declarations
#
round-state =
  element round-state { attlist.round-state, empty }
attlist.round-state &=
  att.nm,
  attribute period {
      "half-pixel"
    | "one-pixel"
    | "two-pixel"
  },
  attribute phase {
      "zero"
    | "one-quarter"
    | "one-half"
    | "three-quarters"
  },
  attribute threshold {
      "period-minus-one"
    | "minus-three-eighths"
    | "minus-one-quarter"
    | "minus-one-eighth"
    | "zero"
    | "one-eighth"
    | "one-quarter"
    | "three-eighths"
    | "one-half"
    | "five-eighths"
    | "three-quarters"
    | "seven-eighths"
    | "one"
    | "nine-eighths"
    | "five-quarters"
    | "eleven-eighths"
  }
\default = element default { attlist.default, empty }
attlist.default &=
  attribute type {
      "minimum-distance"
    | "control-value-cut-in"
    | "single-width"
    | "single-width-cut-in"
    | "delta-base"
    | "delta-shift"
    | "delta-break"
    | "push-break"
    | "max-twilight-points"
    | "max-storage"
    | "legacy-storage"
    | "max-stack"
    | "use-truetype-defaults"
    | "round-state"
    | "function-base"
    | "compile-globals"
    | "init-graphics"
    | "color"
    | "delete-all"
    | "combine-prep"
    | "auto-instr"
    | "auto-hint"
    | "cv-num-in-compile-if"
  },
  att.val
region =
  element region { attlist.region, cvv+ }
attlist.region &=
  attribute tag { text },
  attribute top { text },
  attribute bot { text },
  attribute peak { text }
cvar =
  element cvar { region+ }
cvv =
  element cvv { attlist.cvv, empty }
attlist.cvv &=
  attribute index { text }?,
  att.nm,
  attribute val { xsd:int }
cv =
  element cv { attlist.cv, empty }
attlist.cv &=
  attribute index { text }?,
  att.nm,
  attribute val { xsd:int }
fn =
  element fn {
    attlist.fn,
    fn.pm*,
    (var|alias)*,
    programming*,
    variant*
  }
attlist.fn &=
  att.nm,
  att.id?,
  attribute num { xsd:nonNegativeInteger }?,
  attribute return { YESNO }?
variant =
  element variant { att.test, programming* }
mo =
  element mo {
    attlist.mo, pm*, alias*, programming*
  }
attlist.mo &=
  att.nm,
  att.id?
fn.pm =
  element pm { attlist.pm }
pm =
  element pm { attlist.pm, ((set | range ) | programming+)? }
attlist.pm &=
  att.nm,
  att.val?
legacy-functions =
  element legacy-functions {
    attlist.legacy-functions, programming*
  }
attlist.legacy-functions &=
  attribute max-function-defs { xsd:nonNegativeInteger }
prep =
  element prep { att.id?, (var|alias)*, programming* }
gl =
  element gl {
    attlist.gl,
    pm*,
    (cn|alias|var|range|set)*,
    programming*
  }
attlist.gl &=
  att.pnm,
  attribute init-graphics { YESNO }?,
  att.id?
#
# Miscellaneous / Oddball
#
message = element message { text }
#
# Points and point structures
#
pt =
  element pt { attlist.pt, empty }
attlist.pt &=
  att.n
ref =
  element ref { pt }
dual.ref =
  element ref { pt, pt }
range = element range {
    attlist.range, (att.ref | (att.p | (pt, pt)))
  }
attlist.range &=
  att.nm?
set = element set {
    attlist.set, (att.ref | (att.p | pt)+)
  }
attlist.set &=
  att.nm?
#
# Point-moving instructions
#
sh =
  element sh {
    attlist.sh,
    (att.r | ref)?,
    ( (att.p | pt) | range | set )+
  }
attlist.sh &=
  attribute ref-ptr { "1" | "2" }?,
  att.compile-if?,
  att.round?
al =
  element al {
    att.compile-if?, (att.r | ref)?, ( (att.p | pt) | range | set )+
  }
ip =
  element ip {
    attlist.ip, (att.r | dual.ref)?, (  (att.p | pt) | range | set )+
  }
attlist.ip &=
  att.compile-if?,
  att.round?
iup =
  element iup { att.axis?, empty }
top.level.mv =
  element mv {
    attlist.mv,
      (((att.r | ref), (att.p | pt), nested.delta*,
      (al*& ip*& sh*),
      nested.mv*, nested.delta*)
    | ((att.p | pt), nested.delta*,
      (al*& sh*),
      nested.mv*, nested.delta*))
  }
nested.mv =
  element mv {
    attlist.mv,
    (att.p | pt), nested.delta*,
    (al*& ip*& sh*),
    nested.mv*, nested.delta*
  }
attlist.mv &=
  (att.di? | att.pixel-distance?),
  att.round?,
  attribute cut-in { text }?,
  att.val.min-distance?,
  att.color?,
  att.compile-if?
top.level.delta =
  element delta {
    att.compile-if?,
    ((pt, (pt.delta-set | empty.delta-set)+) |
     pt.delta-set+)
  }
nested.delta =
  element delta { att.compile-if?,
    pt?, (pt.delta-set | empty.delta-set)+ }
control-value-delta =
  element control-value-delta { cv.delta-set+ }
cv.delta-set =
  element delta-set { attlist.cv.delta-set, empty }
attlist.cv.delta-set &=
  attribute cv { xsd:NCName },
  attlist.delta-set-basic
pt.delta-set =
  element delta-set { attlist.delta-set-basic, pt }
empty.delta-set =
  element delta-set { attlist.delta-set-basic, empty }
#
# Enable/disable instructions
#
disable-instructions =
  element disable-instructions { empty }
enable-instructions =
  element enable-instructions { empty }
#
# Graphics state
#
setvs =
  element setvs { model.set-vector }
wvs =
  element wvs { model.with-vector }
srp =
  element srp { att.whichpointer, (att.p | pt) }
set-dropout-control =
  element set-dropout-control { attlist.set-dropout-control, empty }
attlist.set-dropout-control &=
  attribute threshold { xsd:nonNegativeInteger {maxInclusive = "255"} },
  attribute flags { xsd:nonNegativeInteger {maxInclusive = "63"} }
set-dropout-type =
  element set-dropout-type { att.dropout.val, empty }
att.dropout.val =
  attribute val { xsd:nonNegativeInteger {maxInclusive = "7"} }
setcv =
  element setcv { attlist.setcv, empty }
wcv =
  element wcv { attlist.setcv, programming* }
attlist.setcv &=
  attlist.val.with.name,
  att.unit?
set-control-value-cut-in =
  element set-control-value-cut-in { att.val, empty }
with-control-value-cut-in =
  element with-control-value-cut-in { att.val, programming* }
set-minimum-distance =
  element set-minimum-distance { att.val, empty }
with-minimum-distance =
  element with-minimum-distance { att.val, programming* }
set-round-state =
  element set-round-state { att.round, empty }
with-round-state =
  element with-round-state { att.round, programming* }
set-delta-base =
  element set-delta-base { att.val, empty }
with-delta-base =
  element with-delta-base { att.val, programming* }
set-delta-shift =
  element set-delta-shift { att.units.per.pixel, empty }
with-delta-shift =
  element with-delta-shift { att.units.per.pixel, programming* }
restore-default =
  element restore-default { attlist.restore-default, empty }
attlist.restore-default &=
  attribute nm {
      "minimum-distance"
    | "control-value-cut-in"
    | "single-width"
    | "single-width-cut-in"
    | "delta-base"
    | "delta-shift"
    | "round-state"
    | "all"
  }
#
# Arithmetic elements
#
set-equal =
  element set-equal { attlist.set-equal, empty }
attlist.set-equal &=
  att.target,
  attribute source { text }
round =
  element round { attlist.round, empty }
no-round =
  element no-round { attlist.round, empty }
attlist.round &=
  att.val,
  att.color?,
  att.result-to?
#
# Function and macro calls
#
pms =
  element pms { text }
callf =
  element callf {
    attlist.callf,
    (pms? | fn.pmset* | fn.wpm*)
  }
attlist.callf &=
  att.nm,
  att.result-to?
callm =
  element callm { att.nm, (pms? | pmset* | wpm*) }
callp =
  element callp { att.nm, empty }
callg =
  element callg { att.pnm, (pms? | wpm*) }
fn.pmset =
  element pmset { attribute opt { YESNO }?, fn.wpm+ }
pmset =
  element pmset { wpm+ }
fn.wpm =
  element wpm { att.nm, att.val, empty }
wpm =
  element wpm {
    att.nm,
    (att.val |
     (att.val?, ((set | range ) | programming+)))
  }
#
# Conditionals
#
if = element if { att.test, programming*, else? }
else = element else { programming* }
compile-if = element compile-if { att.test, programming*, else? }
no-warning = element no-warning { programming* }
#
# Getting info
#
getinfo =
  element getinfo { attlist.getinfo, empty }
attlist.getinfo &=
  attribute selector { text },
  att.result-to?
#
# Primitives
#
command = element command {
    attribute nm { xsd:token { pattern = "[A-Z0-5]{2,9}" } },
    ( attribute modifier { text }? | modifier* )
  }
modifier = element modifier { attlist.modifier, empty }
attlist.modifier &=
  att.val,
  attribute type {
      "set-rp0"
    | "round"
    | "minimum-distance"
    | "color"
    | "grid-fitted"
    | "to-line"
    | "axis"
    | "ref-ptr"
  }
push =
  element push { text }
#
# XInclude
#
xg.xi.include.attlist =
    attribute href { xsd:anyURI }?,
    [ a:defaultValue = "xml" ] attribute parse { "xml" | "text" }?,
    attribute xpointer { text }?,
    attribute encoding { text }?,
    attribute accept { text }?,
    attribute accept-language { text }?
xg.xi.include =
    element xi:include {
      xg.xi.include.attlist
    }

start = xgridfit
